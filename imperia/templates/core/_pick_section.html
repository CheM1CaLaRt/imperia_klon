{% load access %}

<section class="rq-card" id="pick-section">
  <div class="rq-card__head">
    <h2>Сборка со склада</h2>
    <div class="text-sm text-gray-500">Заполняет оператор/директор</div>
  </div>

  <div class="p-3 space-y-2">
    <div class="text-sm font-medium">Позиции к сборке:</div>
    <ul id="pickPreview" class="text-sm text-gray-700 space-y-1">
      <li class="text-gray-400">Пока пусто</li>
    </ul>

    <button type="button" id="openPickModal" class="btn">Открыть форму сборки</button>
  </div>
</section>

<!-- МОДАЛКА -->
<div id="pickModal"
     class="fixed inset-0 hidden items-start justify-center z-50"
     role="dialog" aria-modal="true" aria-labelledby="pickModalTitle">
  <div class="absolute inset-0 bg-black/40" data-close></div>

  <div class="relative mt-10 w-[min(1400px,98vw)] max-h-[90vh] overflow-auto
              rounded-2xl bg-white shadow-xl border border-gray-200">
    <div class="flex items-center justify-between px-5 py-4 border-b">
      <h3 id="pickModalTitle" class="text-xl font-semibold">Сборка со склада</h3>
      <button type="button" class="text-gray-500 hover:text-black text-2xl leading-none"
              title="Закрыть" data-close>&times;</button>
    </div>

    <form id="pickForm" method="post" action="{% url 'core:pick_submit' obj.pk %}" class="p-5">
      {% csrf_token %}
      {{ pick_formset.management_form }}
      <input type="hidden" name="commit" id="pickCommit" value="save">

      <div class="grid grid-cols-12 gap-3 text-sm text-gray-600 mb-2">
        <div class="col-span-3">Штрихкод</div>
        <div class="col-span-3">Название</div>
        <div class="col-span-2">Ячейка</div>
        <div class="col-span-1">Ед.</div>
        <div class="col-span-1">Кол-во</div>
        <div class="col-span-1">Цена</div>
        <div class="col-span-1"></div>
      </div>

      {% for f in pick_formset %}
        <div class="grid grid-cols-12 gap-3 items-start mb-2" data-form-row>
          <div class="col-span-3">{{ f.barcode }}</div>
          <div class="col-span-3" style="position:relative;">{{ f.name }}</div>

          <div class="col-span-2 space-y-1">
            {{ f.location }}
            {% if request.user|in_groups:"operator,director" %}
              <div class="loc-hint text-xs text-red-600 hidden">нет на складе</div>
            {% endif %}
          </div>

          <div class="col-span-1">{{ f.unit }}</div>
          <div class="col-span-1">{{ f.qty }}</div>
          <div class="col-span-1">{{ f.price }}</div>

          <div class="col-span-1 flex items-center justify-center">
            {% if f.DELETE %}<span class="hidden">{{ f.DELETE }}</span>{% endif %}
            <button type="button" class="delete-btn" title="Удалить" data-remove>✖</button>
          </div>

          {% if f.errors %}
            <div class="col-span-12 text-sm text-red-700">
              {{ f.errors }}
            </div>
          {% endif %}
        </div>
      {% endfor %}

      <div class="flex flex-wrap gap-2 mt-4">
        <button type="button" id="addRowBtn" class="btn btn-ghost">+ Добавить строку</button>
      </div>

      <div class="flex flex-wrap gap-2 mt-4">
        <button type="button" id="savePickBtn" class="btn">Сохранить</button>
        <button type="button" class="btn btn-ghost" data-close>Отменить</button>
      </div>
    </form>
  </div>
</div>

<style>
  .delete-btn{color:#dc2626;font-size:18px;font-weight:bold;line-height:1;background:none;border:none;cursor:pointer;transition:transform .1s ease,color .1s ease}
  .delete-btn:hover{color:#b91c1c;transform:scale(1.2)}
  body.modal-open{overflow:hidden}
  .field-error{outline:2px solid #dc2626; outline-offset:0; border-color:#fca5a5}
</style>

<script>
(function () {
  const modal   = document.getElementById('pickModal');
  const openBtn = document.getElementById('openPickModal');
  const form    = document.getElementById('pickForm');
  const saveBtn = document.getElementById('savePickBtn');
  const addBtn  = document.getElementById('addRowBtn');
  const totalInput = form.querySelector('input[name$="-TOTAL_FORMS"]');
  const preview = document.getElementById('pickPreview');

  // Кол-во строк сборки на сервере (рендерится из view)
  const serverPickCount = {{ pick_items|length|default:0 }};
  const DRAFT_KEY = 'pick_draft_req_{{ obj.pk }}';
  let saveTimer = null;

  // ---------- helpers ----------
  function rows() {
    return [...form.querySelectorAll('[data-form-row]')].filter(r => r.style.display !== 'none');
  }
  function rowToData(r) {
    return {
      barcode : r.querySelector('[name$="-barcode"]')?.value || '',
      name    : r.querySelector('[name$="-name"]')?.value || '',
      location: r.querySelector('[name$="-location"]')?.value || '',
      unit    : r.querySelector('[name$="-unit"]')?.value || '',
      qty     : r.querySelector('[name$="-qty"]')?.value || '',
      price   : r.querySelector('[name$="-price"]')?.value || '',
      notfound: r.hasAttribute('data-notfound') ? 1 : 0,
    };
  }
  function getRowsData() { return rows().map(rowToData); }
  function rowsAreAllEmpty() {
    return getRowsData().every(d => !d.barcode && !d.name && !d.location && !d.qty && !d.price);
  }

  function setRowsData(data) {
    if (!Array.isArray(data)) return;
    // подготовим нужное кол-во строк
    let current = rows().length;
    while (current < data.length) { cloneLastRow(true); current++; }
    while (current > data.length && current > 1) {
      const r = rows()[current - 1]; r.remove(); current--;
    }
    renumberForms();

    const list = rows();
    data.forEach((d, i) => {
      const r = list[i];
      const set = (sel, v) => { const el = r.querySelector(sel); if (el) el.value = v || ''; };
      set('[name$="-barcode"]',  d.barcode);
      set('[name$="-name"]',     d.name);
      set('[name$="-location"]', d.location);
      set('[name$="-unit"]',     d.unit);
      set('[name$="-qty"]',      d.qty);
      set('[name$="-price"]',    d.price);
      if (d.notfound) r.setAttribute('data-notfound', '1'); else r.removeAttribute('data-notfound');
    });

    renderPreview();
    updateRowHints();
  }

  // ---------- draft ----------
  function saveDraft() {
    clearTimeout(saveTimer);
    saveTimer = setTimeout(() => {
      const payload = { rows: getRowsData(), ts: Date.now() };
      try { localStorage.setItem(DRAFT_KEY, JSON.stringify(payload)); } catch (_) {}
    }, 120);
  }
  function loadDraft() {
    try {
      const raw = localStorage.getItem(DRAFT_KEY);
      if (!raw) return null;
      const parsed = JSON.parse(raw);
      if (!parsed || !Array.isArray(parsed.rows)) return null;
      // Только если есть реально непустые строки
      const hasMeaning = parsed.rows.some(d => d.barcode || d.name || d.location || d.qty || d.price);
      return hasMeaning ? parsed.rows : null;
    } catch (_) { return null; }
  }
  function clearDraft() {
    try { localStorage.removeItem(DRAFT_KEY); } catch (_) {}
  }

  // ---------- modal ----------
  function openModal() {
    modal.classList.remove('hidden'); modal.classList.add('flex');
    document.body.classList.add('modal-open');

    // ВОССТАНОВЛЕНИЕ ЧЕРНОВИКА:
    //  - текущее состояние пустое
    //  - на сервере сейчас пусто (serverPickCount == 0)
    //  - в storage есть непустой черновик
    const isEmptyNow = rowsAreAllEmpty();
    if (isEmptyNow && serverPickCount === 0) {
      const draft = loadDraft();
      if (draft) setRowsData(draft);
    }

    renderPreview(); updateRowHints();
    const first = modal.querySelector('input,select,textarea,button'); if (first) first.focus();
  }
  function closeModal() {
    // Если всё пусто — очищаем storage. Иначе сохраняем.
    if (rowsAreAllEmpty()) clearDraft(); else saveDraft();
    hideAutocomplete(); // Закрываем автодополнение при закрытии модального окна
    modal.classList.add('hidden'); modal.classList.remove('flex');
    document.body.classList.remove('modal-open');
    renderPreview();
  }
  if (openBtn) openBtn.addEventListener('click', openModal);
  modal.addEventListener('click', (e) => { if (e.target.closest('[data-close]')) closeModal(); });
  document.addEventListener('keydown', (e) => { if (!modal.classList.contains('hidden') && e.key === 'Escape') closeModal(); });

  // ---------- formset ----------
  function renumberForms() {
    rows().forEach((row, idx) => {
      row.querySelectorAll('input, select, textarea, label').forEach(el => {
        if (el.name) el.name = el.name.replace(/pick-(\d+)-/g, `pick-${idx}-`);
        if (el.id)   el.id   = el.id.replace(/pick-(\d+)-/g, `pick-${idx}-`);
        if (el.hasAttribute('for'))
          el.setAttribute('for', el.getAttribute('for').replace(/pick-(\d+)-/g, `pick-${idx}-`));
      });
    });
    if (totalInput) totalInput.value = String(rows().length);
    updateRowHints();
  }

  function cloneLastRow(silent) {
    const r = rows(); if (!r.length) return;
    const last = r[r.length - 1];
    const clone = last.cloneNode(true);
    clone.querySelectorAll('input,select,textarea').forEach(el => {
      if (el.type === 'checkbox') el.checked = false;
      else el.value = '';
    });
    clone.removeAttribute('data-notfound');
    last.parentNode.insertBefore(clone, last.nextSibling);
    renumberForms();
    if (!silent) saveDraft();
  }
  if (addBtn) addBtn.addEventListener('click', () => cloneLastRow(false));

  // удаление
  document.addEventListener('click', (e) => {
    const btn = e.target.closest('[data-remove]'); if (!btn) return;
    const row = btn.closest('[data-form-row]'); if (!row) return;

    const idField  = row.querySelector('input[name$="-id"]');
    const delField = row.querySelector('input[name$="-DELETE"]');
    const hasExistingId = idField && idField.value;

    if (hasExistingId && delField) { delField.checked = true; row.style.display = 'none'; }
    else { row.remove(); renumberForms(); }

    renderPreview();
    // если стало пусто — чистим storage, иначе сохраняем обновлённый черновик
    if (rowsAreAllEmpty()) clearDraft(); else saveDraft();
  });

  // ---------- автодополнение по названию ----------
  let autocompleteTimeout = null;
  let currentAutocompleteRow = null;
  let autocompleteList = null;

  function createAutocompleteList(row) {
    // Удаляем существующий список, если есть
    if (autocompleteList) {
      autocompleteList.remove();
      autocompleteList = null;
    }

    const nameInput = row.querySelector('[name$="-name"]');
    if (!nameInput) return null;

    // Используем fixed позиционирование, чтобы список был виден поверх модального окна
    const nameInputRect = nameInput.getBoundingClientRect();
    
    const list = document.createElement('div');
    list.className = 'autocomplete-list';
    list.style.cssText = 'position:fixed;z-index:10001;background:white;border:1px solid #ccc;border-radius:4px;max-height:200px;overflow-y:auto;box-shadow:0 2px 8px rgba(0,0,0,0.15);margin-top:2px;';
    
    // Позиционируем относительно input поля
    list.style.top = (nameInputRect.bottom + window.scrollY) + 'px';
    list.style.left = nameInputRect.left + 'px';
    list.style.width = nameInputRect.width + 'px';
    
    // Добавляем в body, чтобы не обрезался overflow модального окна
    document.body.appendChild(list);
    
    autocompleteList = list;
    return list;
  }

  function hideAutocomplete() {
    if (autocompleteList) {
      autocompleteList.remove();
      autocompleteList = null;
    }
    currentAutocompleteRow = null;
  }

  async function selectProduct(row, product) {
    hideAutocomplete();
    
    // Дополнительная проверка наличия на складе при выборе
    try {
      const resp = await fetch(`{% url 'core:stock_lookup_by_name_selected' %}?product_id=${product.id}`);
      if (!resp.ok) {
        row.setAttribute('data-notfound', '1');
        updateRowHints();
        return;
      }
      const data = await resp.json();
      if (!data.ok) {
        row.setAttribute('data-notfound', '1');
        updateRowHints();
        return;
      }

      // Обновляем данные из ответа сервера (актуальное наличие)
      const set = (sel, v) => { const el = row.querySelector(sel); if (el) el.value = v || ''; };
      set('[name$="-name"]', data.name);
      set('[name$="-barcode"]', data.barcode);
      set('[name$="-location"]', data.location);
      set('[name$="-unit"]', data.unit);
      const qtyEl = row.querySelector('[name$="-qty"]'); 
      if (qtyEl && !qtyEl.value) qtyEl.value = 1;

      row.removeAttribute('data-notfound');
    } catch (_) {
      row.setAttribute('data-notfound', '1');
    }

    updateRowHints();
    renderPreview();
    saveDraft();
  }

  // ---------- async lookups + автосейв ----------
  document.addEventListener('input', async (e) => {
    const el = e.target;
    if (!el || !el.closest('#pickForm')) return;

    updateRowHints();
    saveDraft();

    const row = el.closest('[data-form-row]');
    if (!row) { renderPreview(); return; }

    // Отладка: проверяем, что обработчик срабатывает
    if (el.name) {
      console.log('Обработка input события для поля:', el.name, 'значение:', el.value);
    }

    // Обработка поиска по названию
    // Проверяем имя поля - может быть pick-0-name, pick-1-name и т.д.
    // Также проверяем по классу pick-name для надежности
    const isNameField = (el.name && el.name.endsWith('-name')) || 
                        (el.classList && el.classList.contains('pick-name'));
    
    if (isNameField) {
      row.removeAttribute('data-notfound');
      const query = el.value.trim();

      // Очищаем предыдущий таймаут
      if (autocompleteTimeout) {
        clearTimeout(autocompleteTimeout);
        autocompleteTimeout = null;
      }

      // Если меньше 3 символов - скрываем список
      if (query.length < 3) {
        hideAutocomplete();
        renderPreview();
        return;
      }

      // Скрываем автодополнение для других строк
      if (currentAutocompleteRow && currentAutocompleteRow !== row) {
        hideAutocomplete();
      }

      // Задержка перед запросом (debounce)
      autocompleteTimeout = setTimeout(async () => {
        try {
          const url = `{% url 'core:stock_lookup_by_name' %}?name=${encodeURIComponent(query)}`;
          console.log('Запрос к API:', url);
          const resp = await fetch(url);
          console.log('Ответ API:', resp.status, resp.ok);
          if (!resp.ok) {
            console.warn('API ответил с ошибкой:', resp.status);
            hideAutocomplete();
            return;
          }
          const data = await resp.json();
          console.log('Данные от API:', data);
          if (!data.ok) {
            console.warn('API вернул data.ok = false');
            hideAutocomplete();
            return;
          }
          if (!data.products || data.products.length === 0) {
            console.log('Товары не найдены');
            hideAutocomplete();
            return;
          }

          console.log('Найдено товаров:', data.products.length);
          currentAutocompleteRow = row;
          const list = createAutocompleteList(row);
          if (!list) {
            console.warn('Не удалось создать список автодополнения');
            return;
          }

          console.log('Список создан, добавляем товары');
          list.innerHTML = '';
          data.products.forEach(product => {
            const item = document.createElement('div');
            item.style.cssText = 'padding:8px 12px;cursor:pointer;border-bottom:1px solid #eee;';
            item.textContent = product.name;
            item.onmouseover = () => item.style.backgroundColor = '#f5f5f5';
            item.onmouseout = () => item.style.backgroundColor = '';
            item.onclick = (e) => {
              e.preventDefault();
              e.stopPropagation();
              selectProduct(row, product);
            };
            list.appendChild(item);
          });

          console.log('Список заполнен, товаров:', list.children.length);

          // Если только один результат - автоматически выбираем его
          if (data.products.length === 1) {
            selectProduct(row, data.products[0]);
          }
        } catch (err) {
          console.error('Ошибка при поиске по названию:', err);
          hideAutocomplete();
        }
      }, 300);
      return;
    }

    // Обработка поиска по штрихкоду (как было раньше)
    if (el.name && el.name.endsWith('-barcode')) {
      row.removeAttribute('data-notfound');
      const bc = el.value.trim();
      
      // Если меньше 6 символов - не ищем
      if (bc.length < 6) { 
        renderPreview(); 
        updateRowHints(); 
        return; 
      }

      try {
        const resp = await fetch(`{% url 'core:stock_lookup_by_barcode' %}?barcode=${encodeURIComponent(bc)}`);
        if (!resp.ok) { 
          row.setAttribute('data-notfound', '1'); 
          updateRowHints(); 
          saveDraft(); 
          return; 
        }
        const data = await resp.json();
        if (!data.ok) { 
          row.setAttribute('data-notfound', '1'); 
          updateRowHints(); 
          saveDraft(); 
          return; 
        }

        const set = (sel, v) => { const el = row.querySelector(sel); if (el) el.value = v || ''; };
        set('[name$="-name"]', data.name);
        set('[name$="-location"]', data.location);
        set('[name$="-unit"]', data.unit);
        const qtyEl = row.querySelector('[name$="-qty"]'); 
        if (qtyEl && !qtyEl.value) qtyEl.value = 1;

        row.removeAttribute('data-notfound');
      } catch (_) {
        row.setAttribute('data-notfound', '1');
      }

      renderPreview(); 
      updateRowHints(); 
      saveDraft();
      return;
    }

    renderPreview();
  });

  // Закрываем автодополнение при клике вне формы
  document.addEventListener('click', (e) => {
    if (!e.target.closest('#pickForm') && !e.target.closest('.autocomplete-list')) {
      hideAutocomplete();
    }
  });

  // Закрываем автодополнение при нажатии Escape
  document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape' && autocompleteList) {
      hideAutocomplete();
    }
  });

  // ---------- preview ----------
  function renderPreview() {
    const list = rows().map(r => {
      const n = r.querySelector('[name$="-name"]')?.value?.trim();
      const q = r.querySelector('[name$="-qty"]')?.value?.trim();
      const u = r.querySelector('[name$="-unit"]')?.value?.trim();
      const p = r.querySelector('[name$="-price"]')?.value?.trim();
      if (!n && !q && !p) return null;
      return { n, q, u, p };
    }).filter(Boolean);

    preview.innerHTML = '';
    if (!list.length) {
      preview.innerHTML = '<li class="text-gray-400">Пока пусто</li>';
      return;
    }
    list.forEach(it => {
      const li = document.createElement('li');
      li.textContent = `${it.n || '—'} — ${it.q || 0} ${it.u || ''}${it.p ? ` · ${it.p}` : ''}`;
      preview.appendChild(li);
    });
  }

  // ---------- hints ----------
  function updateRowHints() {
    rows().forEach(row => {
      const hint = row.querySelector('.loc-hint');
      const loc  = row.querySelector('[name$="-location"]');
      const nameInput = row.querySelector('[name$="-name"]');
      const bcInput = row.querySelector('[name$="-barcode"]');
      if (!loc) return;

      // Показываем подсказку если есть название или штрихкод, но нет ячейки или товар не найден
      const hasInput = (nameInput && nameInput.value.trim()) || (bcInput && bcInput.value.trim());
      const show = hasInput && (!loc.value.trim() || row.hasAttribute('data-notfound'));
      if (hint) hint.classList.toggle('hidden', !show);
      loc.classList.toggle('field-error', show);
    });
  }

  // ---------- ajax save ----------
  async function saveFormAjax() {
    if (!form) return;
    saveBtn.disabled = true;
    const fd = new FormData(form);
    try {
      const resp = await fetch(form.action, { method: 'POST', headers: { 'X-Requested-With': 'XMLHttpRequest' }, body: fd });
      if (!resp.ok) throw new Error('Server error');
      clearDraft();     // сервер принял — черновик больше не нужен
      closeModal();
      location.reload(); // чтобы превью и статусы обновились
    } catch (err) {
      alert('Не удалось сохранить. Проверьте соединение или поля формы.');
    } finally {
      saveBtn.disabled = false;
    }
  }
  if (saveBtn) saveBtn.addEventListener('click', saveFormAjax);

  // ---------- init ----------
  if (totalInput) totalInput.value = String(rows().length);
  renderPreview(); updateRowHints();
})();
</script>
